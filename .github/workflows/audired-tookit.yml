name: Audi RED Toolkit

on:
  workflow_call:
    inputs:
      source_file:
        description: "Source file from the origin directory"
        required: true
        type: string
      destination_repo:
        description: "Destination repository"
        type: string
        required: false
        default: "RED-Internal-Development/audi-red-documentation"
      destination_folder:
        description: "Directory to push the file to"
        type: string
        required: false
      user_email:
        description: "Email for the git commit"
        type: string
        required: true
      user_name:
        description: "GitHub username for the commit"
        type: string
        required: true
      user_actor:
        description: "GitHub username that trigged the pipeline"
        type: string
        required: true
      destination_branch:
        description: "branch to push file to, defaults to main"
        type: string
        required: false
      destination_branch_create:
        description: "Destination branch to create for this commit"
        type: string
        required: false
      commit_message:
        description: "A custom message for the commit"
        type: string
        required: false
      rename:
        description: "Rename the destination file"
        type: string
        required: false
      use_rsync:
        description: "Copy files/directories using rsync instead of cp. Experimental feature, please know your use case"
        type: string
        required: false
      git_server:
        description: "Git server host, default github.com"
        type: string
        required: false
        default: github.com
      msiParentPageIds:
        description: "By default we deployment all feature apps to a documentation sync parent id in msi. If you prefer to deploy elsewhere in this space, list ids"
        default: ""
        type: string
        required: false
      enable_doc_sync:
        description: "Enable doc sync step, DOC_SYNC_KEY is required in secrets"
        type: boolean
        required: true
      enable_scanoss:
        description: "Enable scanoss step, SCANOSS_KEY is required in secrets"
        type: boolean
        required: false
    secrets:
      DOC_SYNC_KEY:
        required: false
        description: "Team key used to copy files to audired"
env:
  NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  doc_sync:
    runs-on: ubuntu-22.04
    if: ${{ always() && inputs.enable_doc_sync }}
    needs: data_sync
    steps:
      - name: Check if branch exists
        id: check_branch
        shell: bash
        run: |
          BRANCH_NAME="${{ inputs.destination_branch }}"
          DESTINATION_REPO="${{ inputs.destination_repo }}"
          API_URL="https://api.github.com/repos/${DESTINATION_REPO}/branches/${BRANCH_NAME}"

          # Query the GitHub API
          response=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${{ secrets.DOC_SYNC_KEY }}" "$API_URL")

          if [ "$response" -eq 200 ]; then
              echo "Branch '${BRANCH_NAME}' exists."
              echo "branch_exists=true" >> $GITHUB_OUTPUT
          else
              echo "Branch '${BRANCH_NAME}' does not exist."
              echo "branch_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout
        uses: actions/checkout@v2

      - name: Eslint check for Docusaurus build compatibility
        run: |
          cd ${{ inputs.source_file }}
          npx docusaurus-mdx-checker

      - name: Install mermaid CLI for parsing
        run: npm install -g @mermaid-js/mermaid-cli

      - name: Validate mermaid.js code can be parsed
        run: |
          mkdir -p diagrams
          folder=${{ inputs.source_file }}
          index=1
          find "$folder" -type f \( -name "*.md" -o -name "*.mdx" \) -print0 | while IFS= read -r -d '' file; do
            echo "Processing markdown file: $file"
            
            in_code_block=false
            mermaid_code=""
            temp_file=$(mktemp)
            TMPDIR=$(mktemp -d)

            while IFS= read -r line; do
              if [[ "$line" == '```mermaid' ]]; then
                in_code_block=true
                mermaid_code=""
                continue
              elif [[ "$line" == '```' && "$in_code_block" == true ]]; then
                echo "Found Mermaid diagram:"
                echo "$mermaid_code"
                
                # Write the Mermaid code to a temporary .mmd file and generate the SVG
                diagram_name="diagram_${index}.mmd"
                echo "$mermaid_code" > "diagrams/${diagram_name}"

                if ! mmdc -i "diagrams/${diagram_name}" -o "$TMPDIR/output_${index}.svg" 2> "$TMPDIR/mmdc_error.log"; then
                  echo "❌ Mermaid validation failed in file:"
                  cat "$TMPDIR/mmdc_error.log"
                  exit 1
                fi
                
                in_code_block=false
                index=$((index + 1))
              elif [[ "$in_code_block" == true ]]; then
                mermaid_code="$mermaid_code$line"$'\n'
              else
                echo "$line" >> "$temp_file"
              fi
            done < "$file"
          done
          echo "✅ All Mermaid blocks are valid!"

      - name: Create images from structurizr dsl files
        uses: RED-Internal-Development/audired_structurizr_action@main

      - name: Check if referenced images exist
        run: |
          find docs/ -type f \( -name "*.md" -o -name "*.mdx" \) -print0 | while IFS= read -r -d '' md_file; do
                echo "Checking file: $md_file"
                
                grep -oP '!\[.*?\]\(\K(.*?)(?=\))' "$md_file" | while read -r image; do
                    image=$(echo "$image" | sed 's/[?#].*$//')
                    if [[ "$image" =~ ^https?:// ]]; then
                        echo "Skipping external image: $image"
                        continue
                    elif [[ "$image" =~ ^/ ]]; then
                        IMAGE_PATH="$GITHUB_WORKSPACE$image"
                    else
                        IMAGE_PATH="$(dirname "$md_file")/$image"
                    fi

                    IMAGE_PATH=$(realpath "$IMAGE_PATH")

                    if [[ ! -f "$IMAGE_PATH" ]]; then
                        echo "Image '$image' referenced in '$md_file' does not exist at '$IMAGE_PATH'."
                        exit 1
                    fi
                done
            done

            echo "All images are properly referenced and exist!"

      - name: Pushes files from Feature App to Audi RED Portal for syndication
        uses: RED-Internal-Development/audred_docsync_action@main
        env:
          API_TOKEN_GITHUB: ${{ secrets.DOC_SYNC_KEY }}
        with:
          source_file: ${{ inputs.source_file }}
          destination_repo: ${{ inputs.destination_repo }}
          destination_folder: ${{ inputs.destination_folder }}
          destination_branch: ${{ inputs.destination_branch }}
          user_email: ${{ inputs.user_email }}
          user_name: ${{ inputs.user_name }}
          user_actor: ${{ github.actor }}
          use_rsync: true
          destination_branch_exists: ${{ steps.check_branch.outputs.branch_exists }}

  data_sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout AudiRed Doc Sync repository
        uses: actions/checkout@v3
        with:
          repository: ${{ inputs.destination_repo }}
          token: ${{ secrets.DOC_SYNC_KEY }}
          ref: doc-sync-queue   

      - name: Dynamically create docs destination folder variables
        id: create-docs-folders
        run: |
          app_name=$(basename ${{ inputs.source_file }})
          docs_branch="${{ inputs.destination_branch }}"
          docs_destination_team_folder="docs/feature_apps/${{ inputs.destination_branch }}"
          docs_destination_app_folder="$docs_destination_team_folder/$app_name"

          echo "docs_destination_team_folder=$docs_destination_team_folder" >> $GITHUB_OUTPUT
          echo "docs_branch=$docs_branch" >> $GITHUB_ENV
          echo "docs_destination_team_folder=$docs_destination_team_folder" >> $GITHUB_ENV
          echo "docs_destination_app_folder=$docs_destination_app_folder" >> $GITHUB_ENV

      - name: Update data/report.json with additional metadata
        run: |
          data_folder="data"
          collection_report_file_path="collection-report/report.json"
          mkdir -p "collection-report"
          echo "{}" > $collection_report_file_path
          report_artifact_json=$(cat $collection_report_file_path)

          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          updated_report_artifact_json=$(echo "$report_artifact_json" | \
            jq --arg timestamp "$timestamp" '.timestamp = $timestamp')
          echo "$updated_report_artifact_json" > collection-report/report.json

          mkdir -p "$data_folder"
          if [ ! -f "$data_folder"/report.json ]; then
              echo "{}" > "$data_folder"/report.json
          fi
          jq --argjson new_report "$updated_report_artifact_json" \
            '. * $new_report' "$data_folder"/report.json > tmp_report.json
          mv tmp_report.json "$data_folder"/report.json

      - name: Upload final report
        if: github.event.workflow_run.id != ''
        uses: actions/upload-artifact@v4
        with:
          name: data-report
          path: collection-report/report.json

      - name: Commit and push changes
        run: |
          git config --global user.email ${{ inputs.user_email }}
          git config --global user.name ${{ inputs.user_name }}
          git add data/report.json
          git add deployment/
          if ! git diff-index --quiet HEAD; then
              echo "commiting changes"
              git commit -m "Update report.json and deployment config from ${{ inputs.destination_branch }}"
              git push
          else
              echo "No changes to push"
          fi